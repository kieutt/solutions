# ğŸ“˜ Tutorial: Äáº¿m BÆ°á»›c Äi TrÃªn CÃ¢y

> **Äá»™ khÃ³:** KhÃ³  
> **Chá»§ Ä‘á»:** Tree DP, Combinatorics  
> **Kiáº¿n thá»©c:** DFS, Quy hoáº¡ch Ä‘á»™ng trÃªn cÃ¢y, TÃ­ch tiá»n tá»‘/háº­u tá»‘

---

## ğŸ“‹ Má»¥c lá»¥c

1. [TÃ³m táº¯t Ä‘á» bÃ i](#1-tÃ³m-táº¯t-Ä‘á»-bÃ i)
2. [PhÃ¢n tÃ­ch vÃ­ dá»¥](#2-phÃ¢n-tÃ­ch-vÃ­-dá»¥)
3. [MÃ´ hÃ¬nh hÃ³a bÃ i toÃ¡n](#3-mÃ´-hÃ¬nh-hÃ³a-bÃ i-toÃ¡n)
4. [CÃ¡c nháº­n xÃ©t quan trá»ng](#4-cÃ¡c-nháº­n-xÃ©t-quan-trá»ng)
5. [PhÃ¢n rÃ£ bÃ i toÃ¡n con](#5-phÃ¢n-rÃ£-bÃ i-toÃ¡n-con)
6. [XÃ¢y dá»±ng cÃ´ng thá»©c](#6-xÃ¢y-dá»±ng-cÃ´ng-thá»©c)
7. [Thuáº­t toÃ¡n chi tiáº¿t](#7-thuáº­t-toÃ¡n-chi-tiáº¿t)
8. [PhÃ¢n tÃ­ch Ä‘á»™ phá»©c táº¡p](#8-phÃ¢n-tÃ­ch-Ä‘á»™-phá»©c-táº¡p)
9. [Kiáº¿n thá»©c cáº§n chuáº©n bá»‹](#9-kiáº¿n-thá»©c-cáº§n-chuáº©n-bá»‹)
10. [Code máº«u](#10-code-máº«u)
11. [CÃ¡c lá»—i thÆ°á»ng gáº·p](#11-cÃ¡c-lá»—i-thÆ°á»ng-gáº·p)

---

## 1. TÃ³m táº¯t Ä‘á» bÃ i

### Äáº§u vÃ o
- CÃ¢y $T$ gá»“m $n$ Ä‘á»‰nh, gá»‘c táº¡i Ä‘á»‰nh $1$
- Äá»‰nh xuáº¥t phÃ¡t $s$
- $n-1$ cáº¡nh $(u, v)$ vá»›i $1 \le u, v \le n$, $u \neq v$

### Quy táº¯c di chuyá»ƒn
- Tá»« Ä‘á»‰nh $u$, Ä‘i Ä‘áº¿n báº¥t ká»³ Ä‘á»‰nh ká» nÃ o
- **Quan trá»ng:** Náº¿u Ä‘i tá»« $u$ lÃªn cha $f$ â†’ cáº¡nh $(u, f)$ bá»‹ **xÃ³a ngay láº­p tá»©c**
- Dá»«ng khi Ä‘á»‰nh hiá»‡n táº¡i khÃ´ng cÃ²n cáº¡nh ká»

### YÃªu cáº§u
- Hai phÆ°Æ¡ng Ã¡n **báº£n cháº¥t khÃ¡c nhau** âŸº tá»“n táº¡i Ä‘á»‰nh Ä‘Æ°á»£c thÄƒm trong phÆ°Æ¡ng Ã¡n nÃ y nhÆ°ng khÃ´ng Ä‘Æ°á»£c thÄƒm trong phÆ°Æ¡ng Ã¡n kia
- TÃ­nh **tá»•ng sá»‘ bÆ°á»›c** cá»§a táº¥t cáº£ phÆ°Æ¡ng Ã¡n báº£n cháº¥t khÃ¡c nhau
- Káº¿t quáº£ mod $10^9 + 7$

### RÃ ng buá»™c
- $1 \le s \le n \le 10^6$

---

## 2. PhÃ¢n tÃ­ch vÃ­ dá»¥

### Cáº¥u trÃºc cÃ¢y

```
        1           â† Gá»‘c (káº¿t thÃºc táº¡i Ä‘Ã¢y)
        |
        2
       / \
      3   4
     / \
    5   7
    |
   6

ÄÆ°á»ng chÃ­nh: 5 â†’ 3 â†’ 2 â†’ 1
NhÃ¡nh phá»¥: {4}, {6}, {7}
```

### 8 phÆ°Æ¡ng Ã¡n báº£n cháº¥t khÃ¡c nhau

| # | PhÆ°Æ¡ng Ã¡n | Äá»‰nh thÄƒm | Sá»‘ bÆ°á»›c |
|---|-----------|-----------|---------|
| 1 | 5â†’3â†’2â†’1 | {5,3,2,1} | 3 |
| 2 | 5â†’3â†’7â†’3â†’2â†’1 | {5,3,2,1,7} | 5 |
| 3 | 5â†’3â†’7â†’3â†’2â†’4â†’2â†’1 | {5,3,2,1,7,4} | 7 |
| 4 | 5â†’3â†’2â†’4â†’2â†’1 | {5,3,2,1,4} | 5 |
| 5 | 5â†’6â†’5â†’3â†’2â†’1 | {5,3,2,1,6} | 5 |
| 6 | 5â†’6â†’5â†’3â†’7â†’3â†’2â†’1 | {5,3,2,1,6,7} | 7 |
| 7 | 5â†’6â†’5â†’3â†’2â†’4â†’2â†’1 | {5,3,2,1,6,4} | 7 |
| 8 | 5â†’6â†’5â†’3â†’7â†’3â†’2â†’4â†’2â†’1 | {5,3,2,1,6,7,4} | 9 |

**Tá»•ng:** $3+5+7+5+5+7+7+9 = 48$

### Quan sÃ¡t tá»« vÃ­ dá»¥

1. **ÄÆ°á»ng chÃ­nh** $\{5,3,2,1\}$ luÃ´n Ä‘Æ°á»£c thÄƒm trong má»i phÆ°Æ¡ng Ã¡n
2. Má»—i nhÃ¡nh phá»¥ $\{4\}, \{6\}, \{7\}$ cÃ³ thá»ƒ **chá»n hoáº·c khÃ´ng chá»n** thÄƒm
3. Sá»‘ phÆ°Æ¡ng Ã¡n = $2^3 = 8$ (má»—i nhÃ¡nh cÃ³ 2 lá»±a chá»n)
4. ThÄƒm 1 Ä‘á»‰nh nhÃ¡nh = thÃªm 2 bÆ°á»›c (Ä‘i vÃ o + Ä‘i ra)

---

## 3. MÃ´ hÃ¬nh hÃ³a bÃ i toÃ¡n

### BÆ°á»›c 1: XÃ¡c Ä‘á»‹nh cáº¥u trÃºc

Gá»i **Ä‘Æ°á»ng chÃ­nh** lÃ  Ä‘Æ°á»ng Ä‘i tá»« $s$ Ä‘áº¿n gá»‘c $1$:
$$P = \{p_0 = s, p_1, p_2, \ldots, p_m = 1\}$$

CÃ¡c Ä‘á»‰nh **khÃ´ng thuá»™c** Ä‘Æ°á»ng chÃ­nh táº¡o thÃ nh cÃ¡c **cÃ¢y con nhÃ¡nh**.

### BÆ°á»›c 2: Äáº·c trÆ°ng phÆ°Æ¡ng Ã¡n

Má»™t phÆ°Æ¡ng Ã¡n Ä‘Æ°á»£c xÃ¡c Ä‘á»‹nh **hoÃ n toÃ n** bá»Ÿi táº­p Ä‘á»‰nh Ä‘Æ°á»£c thÄƒm.

**Nháº­n xÃ©t:** Vá»›i má»—i cÃ¢y con nhÃ¡nh, ta cÃ³ thá»ƒ:
- KhÃ´ng thÄƒm gÃ¬ cáº£
- ThÄƒm má»™t táº­p con cÃ¡c Ä‘á»‰nh (theo quy táº¯c: muá»‘n thÄƒm con thÃ¬ pháº£i thÄƒm cha)

### BÆ°á»›c 3: CÃ´ng thá»©c tá»•ng bÆ°á»›c

$$\text{Tá»•ng bÆ°á»›c} = \sum_{\text{phÆ°Æ¡ng Ã¡n } A} \text{steps}(A)$$

Trong Ä‘Ã³:
$$\text{steps}(A) = |P| - 1 + 2 \times |\text{Ä‘á»‰nh nhÃ¡nh Ä‘Æ°á»£c thÄƒm}|$$

- $|P| - 1 = m$: sá»‘ bÆ°á»›c Ä‘i trÃªn Ä‘Æ°á»ng chÃ­nh (cá»‘ Ä‘á»‹nh)
- Má»—i Ä‘á»‰nh nhÃ¡nh Ä‘Ã³ng gÃ³p 2 bÆ°á»›c

---

## 4. CÃ¡c nháº­n xÃ©t quan trá»ng

### Nháº­n xÃ©t 1: LuÃ´n káº¿t thÃºc táº¡i gá»‘c

> **Chá»©ng minh:** Äá»ƒ dá»«ng láº¡i, ta pháº£i Ä‘á»©ng á»Ÿ Ä‘á»‰nh khÃ´ng cÃ²n cáº¡nh ká». VÃ¬ má»—i láº§n Ä‘i lÃªn cha thÃ¬ xÃ³a cáº¡nh, vÃ  ta pháº£i xÃ³a háº¿t cáº¡nh má»›i dá»«ng Ä‘Æ°á»£c, nÃªn chá»‰ cÃ³ thá»ƒ dá»«ng táº¡i gá»‘c sau khi Ä‘Ã£ thÄƒm táº¥t cáº£ cÃ¢y con cá»§a gá»‘c.

**Há»‡ quáº£:** Táº¡i gá»‘c, ta **báº¯t buá»™c** pháº£i thÄƒm táº¥t cáº£ cÃ¢y con.

### Nháº­n xÃ©t 2: TÃ­nh Ä‘á»™c láº­p cá»§a cÃ¡c nhÃ¡nh

> Viá»‡c chá»n thÄƒm hay khÃ´ng thÄƒm má»™t cÃ¢y con nhÃ¡nh **khÃ´ng áº£nh hÆ°á»Ÿng** Ä‘áº¿n cÃ¡c cÃ¢y con khÃ¡c.

**Ã nghÄ©a:** Ta cÃ³ thá»ƒ tÃ­nh riÃªng cho tá»«ng cÃ¢y con rá»“i **nhÃ¢n** káº¿t quáº£ láº¡i.

### Nháº­n xÃ©t 3: Cáº¥u trÃºc Ä‘á»‡ quy cá»§a cÃ¢y con

> Trong má»™t cÃ¢y con gá»‘c $v$:
> - Náº¿u khÃ´ng thÄƒm $v$: khÃ´ng thÄƒm gÃ¬ cáº£
> - Náº¿u thÄƒm $v$: pháº£i thÄƒm $v$, vÃ  vá»›i má»—i con cá»§a $v$, ta láº¡i cÃ³ bÃ i toÃ¡n con tÆ°Æ¡ng tá»±

### Nháº­n xÃ©t 4: ÄÃ³ng gÃ³p bÆ°á»›c cá»§a má»—i Ä‘á»‰nh

> Má»—i Ä‘á»‰nh nhÃ¡nh Ä‘Æ°á»£c thÄƒm Ä‘Ã³ng gÃ³p **Ä‘Ãºng 2 bÆ°á»›c** (vÃ o vÃ  ra).

**Chá»©ng minh:** Khi vÃ o má»™t cÃ¢y con tá»« Ä‘á»‰nh $p$ trÃªn Ä‘Æ°á»ng chÃ­nh, ta pháº£i quay láº¡i $p$ Ä‘á»ƒ tiáº¿p tá»¥c Ä‘i lÃªn. Má»—i Ä‘á»‰nh trong cÃ¢y con Ä‘Æ°á»£c Ä‘i qua Ä‘Ãºng 2 láº§n.

---

## 5. PhÃ¢n rÃ£ bÃ i toÃ¡n con

### BÃ i toÃ¡n con 1: TÃ¬m Ä‘Æ°á»ng chÃ­nh

**Input:** CÃ¢y $T$, Ä‘á»‰nh $s$  
**Output:** Danh sÃ¡ch Ä‘á»‰nh $P = \{s, p_1, \ldots, 1\}$

**CÃ¡ch giáº£i:** BFS/DFS tá»« gá»‘c Ä‘á»ƒ tÃ¬m cha cá»§a má»—i Ä‘á»‰nh, sau Ä‘Ã³ Ä‘i ngÆ°á»£c tá»« $s$ lÃªn gá»‘c.

### BÃ i toÃ¡n con 2: Äáº¿m sá»‘ cÃ¡ch trong cÃ¢y con

**Input:** CÃ¢y con gá»‘c $v$ (khÃ´ng thuá»™c Ä‘Æ°á»ng chÃ­nh)  
**Output:** 
- $f(v)$: sá»‘ cÃ¡ch xá»­ lÃ½ cÃ¢y con (bao gá»“m cáº£ "khÃ´ng thÄƒm")
- $s(v)$: tá»•ng sá»‘ Ä‘á»‰nh Ä‘Æ°á»£c thÄƒm qua táº¥t cáº£ cÃ¡c cÃ¡ch (khi thÄƒm $v$)

### BÃ i toÃ¡n con 3: Tá»•ng há»£p káº¿t quáº£

**Input:** CÃ¡c giÃ¡ trá»‹ $f, s$ cá»§a cÃ¡c cÃ¢y con nhÃ¡nh  
**Output:** Tá»•ng sá»‘ bÆ°á»›c

---

## 6. XÃ¢y dá»±ng cÃ´ng thá»©c

### 6.1. CÃ´ng thá»©c Ä‘á»‡ quy cho $f(v)$ vÃ  $s(v)$

**TrÆ°á»ng há»£p cÆ¡ sá»Ÿ:** $v$ lÃ  lÃ¡
$$f(v) = 2, \quad s(v) = 1$$
- 2 cÃ¡ch: thÄƒm hoáº·c khÃ´ng thÄƒm
- Náº¿u thÄƒm: thÄƒm Ä‘Ãºng 1 Ä‘á»‰nh

**TrÆ°á»ng há»£p Ä‘á»‡ quy:** $v$ cÃ³ cÃ¡c con $c_1, c_2, \ldots, c_k$

$$f(v) = 1 + \prod_{i=1}^{k} f(c_i)$$

- Sá»‘ 1: khÃ´ng thÄƒm $v$
- TÃ­ch: thÄƒm $v$, rá»“i vá»›i má»—i con cÃ³ $f(c_i)$ cÃ¡ch

$$s(v) = \prod_{i=1}^{k} f(c_i) + \sum_{i=1}^{k} \left( s(c_i) \times \prod_{j \neq i} f(c_j) \right)$$

- Pháº§n tÃ­ch Ä‘áº§u: Ä‘áº¿m chÃ­nh Ä‘á»‰nh $v$
- Pháº§n tá»•ng: Ä‘Ã³ng gÃ³p tá»« cÃ¡c cÃ¢y con

### 6.2. Xá»­ lÃ½ Ä‘áº·c biá»‡t táº¡i gá»‘c

Táº¡i **gá»‘c (Ä‘á»‰nh 1)**, ta **báº¯t buá»™c** pháº£i thÄƒm táº¥t cáº£ cÃ¢y con (theo Nháº­n xÃ©t 1).

â†’ DÃ¹ng $(f(c) - 1)$ thay vÃ¬ $f(c)$ Ä‘á»ƒ loáº¡i bá» lá»±a chá»n "khÃ´ng thÄƒm".

### 6.3. CÃ´ng thá»©c tá»•ng há»£p

Gá»i cÃ¡c Ä‘á»‰nh trÃªn Ä‘Æ°á»ng chÃ­nh lÃ  $p_0, p_1, \ldots, p_m$.

Vá»›i má»—i $p_i$, Ä‘á»‹nh nghÄ©a:
- $H_i$ = tÃ­ch cÃ¡c factor cá»§a cÃ¡c cÃ¢y con nhÃ¡nh táº¡i $p_i$
- $G_i$ = tá»•ng $s$ cá»§a cÃ¡c cÃ¢y con nhÃ¡nh táº¡i $p_i$

**Factor:**
$$\text{factor}(c) = \begin{cases} f(c) - 1 & \text{náº¿u } p_i = 1 \text{ (gá»‘c)} \\ f(c) & \text{ngÆ°á»£c láº¡i} \end{cases}$$

**Sá»‘ phÆ°Æ¡ng Ã¡n:**
$$N = \prod_{i=0}^{m} H_i$$

**Tá»•ng Ä‘á»‰nh nhÃ¡nh Ä‘Æ°á»£c thÄƒm:**
$$\text{total\_visited} = \sum_{i=0}^{m} \left( G_i \times \prod_{j \neq i} H_j \right)$$

**Káº¿t quáº£ cuá»‘i cÃ¹ng:**
$$\boxed{\text{Answer} = N \times m + 2 \times \text{total\_visited}}$$

---

## 7. Thuáº­t toÃ¡n chi tiáº¿t

### BÆ°á»›c 1: Äá»c input vÃ  xÃ¢y dá»±ng cÃ¢y

```
Äá»c n, s
Äá»c n-1 cáº¡nh, lÆ°u vÃ o danh sÃ¡ch ká» adj[]
```

### BÆ°á»›c 2: Root cÃ¢y táº¡i Ä‘á»‰nh 1

```
BFS tá»« Ä‘á»‰nh 1
Vá»›i má»—i Ä‘á»‰nh v, lÆ°u parent[v] vÃ  children[v]
```

### BÆ°á»›c 3: TÃ¬m Ä‘Æ°á»ng chÃ­nh

```
path = []
v = s
while v != 0:
    path.append(v)
    mark on_path[v] = true
    v = parent[v]
depth = len(path) - 1
```

### BÆ°á»›c 4: TÃ­nh f[] vÃ  s[] cho cÃ¡c cÃ¢y con nhÃ¡nh

```
Vá»›i má»—i Ä‘á»‰nh p trÃªn Ä‘Æ°á»ng chÃ­nh:
    Vá»›i má»—i con c cá»§a p:
        Náº¿u c khÃ´ng thuá»™c Ä‘Æ°á»ng chÃ­nh:
            DFS(c) Ä‘á»ƒ tÃ­nh f[c], s[c]
```

**DFS tÃ­nh f vÃ  s (dáº¡ng iterative Ä‘á»ƒ trÃ¡nh stack overflow):**

```
function compute_fs(root):
    stack = [(root, 0)]  # (node, child_index)
    
    while stack not empty:
        (u, idx) = stack.top()
        
        if idx < len(children[u]):
            c = children[u][idx]
            stack.top().idx++
            stack.push((c, 0))
        else:
            stack.pop()
            
            if children[u] is empty:
                f[u] = 2
                s[u] = 1
            else:
                prod = 1
                for c in children[u]:
                    prod *= f[c]
                f[u] = 1 + prod
                
                sum_s = prod  # Ä‘áº¿m chÃ­nh u
                for c in children[u]:
                    sum_s += s[c] * (prod / f[c])
                s[u] = sum_s
```

### BÆ°á»›c 5: TÃ­nh H[] vÃ  G[] cho Ä‘Æ°á»ng chÃ­nh

```
for i = 0 to m:
    p = path[i]
    H[i] = 1
    G[i] = 0
    
    for c in non_path_children[p]:
        factor = (f[c] - 1) if (p == 1) else f[c]
        
        # Cáº­p nháº­t G trÆ°á»›c khi cáº­p nháº­t H
        G[i] = G[i] * factor + s[c] * H[i]
        H[i] = H[i] * factor
```

### BÆ°á»›c 6: TÃ­nh káº¿t quáº£ cuá»‘i cÃ¹ng

```
# DÃ¹ng prefix-suffix Ä‘á»ƒ tÃ­nh hiá»‡u quáº£
prefix[0] = 1
for i = 0 to m-1:
    prefix[i+1] = prefix[i] * H[i]

N = prefix[m+1]  # tÃ­ch táº¥t cáº£ H

suffix[m+1] = 1
for i = m downto 0:
    suffix[i] = suffix[i+1] * H[i]

total_visited = 0
for i = 0 to m:
    total_visited += G[i] * prefix[i] * suffix[i+1]

answer = N * depth + 2 * total_visited
```

---

## 8. PhÃ¢n tÃ­ch Ä‘á»™ phá»©c táº¡p

### Thá»i gian

| BÆ°á»›c | Äá»™ phá»©c táº¡p | Giáº£i thÃ­ch |
|------|-------------|------------|
| Root cÃ¢y | $O(n)$ | BFS má»™t láº§n |
| TÃ¬m Ä‘Æ°á»ng chÃ­nh | $O(n)$ | Tá»‘i Ä‘a $n$ Ä‘á»‰nh |
| TÃ­nh f[], s[] | $O(n)$ | Má»—i Ä‘á»‰nh xá»­ lÃ½ má»™t láº§n |
| TÃ­nh H[], G[] | $O(n)$ | Tá»•ng sá»‘ cÃ¢y con nhÃ¡nh â‰¤ $n$ |
| Tá»•ng há»£p káº¿t quáº£ | $O(n)$ | Prefix-suffix |

**Tá»•ng:** $O(n)$

### KhÃ´ng gian

| ThÃ nh pháº§n | Äá»™ phá»©c táº¡p |
|------------|-------------|
| Danh sÃ¡ch ká» | $O(n)$ |
| Máº£ng f[], s[] | $O(n)$ |
| Stack DFS | $O(n)$ |
| ÄÆ°á»ng chÃ­nh | $O(n)$ |

**Tá»•ng:** $O(n)$

---

## 9. Kiáº¿n thá»©c cáº§n chuáº©n bá»‹

### 9.1. Cáº¥u trÃºc dá»¯ liá»‡u

- **Danh sÃ¡ch ká» (Adjacency List):** LÆ°u cÃ¢y hiá»‡u quáº£
- **Stack:** DFS iterative

### 9.2. Thuáº­t toÃ¡n

- **BFS/DFS:** Duyá»‡t cÃ¢y
- **Tree DP:** Quy hoáº¡ch Ä‘á»™ng trÃªn cÃ¢y

### 9.3. ToÃ¡n há»c

- **Sá»‘ há»c modular:** PhÃ©p cá»™ng, nhÃ¢n mod $10^9+7$
- **TÃ­ch tiá»n tá»‘/háº­u tá»‘:** TÃ­nh $\prod_{j \neq i}$ trong $O(n)$

### 9.4. Ká»¹ thuáº­t láº­p trÃ¬nh

- **Iterative DFS:** TrÃ¡nh stack overflow vá»›i $n = 10^6$
- **Fast I/O:** Äá»c input nhanh vá»›i $n$ lá»›n

---

## 10. Code máº«u

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const long long NoD = 1e9 + 7;
const int MAXN = 1000006;

int n, start_node;
int head[MAXN], nxt[MAXN * 2], to[MAXN * 2], edge_cnt;
int parent_node[MAXN];
int ch_head[MAXN], ch_nxt[MAXN], ch_to[MAXN], ch_cnt;
bool on_path[MAXN], visited[MAXN];
long long f_val[MAXN], s_val[MAXN];
long long prefix_buf[MAXN];
int q[MAXN], stk[MAXN], stk_e[MAXN], path[MAXN], ch[MAXN], npc[MAXN];
long long H[MAXN], G[MAXN];

// Fast input
inline int read() {
    int x = 0; char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
    return x;
}

// Add edge to adjacency list
inline void add_edge(int u, int v) {
    to[edge_cnt] = v;
    nxt[edge_cnt] = head[u];
    head[u] = edge_cnt++;
}

// Add child to children list
inline void add_child(int u, int v) {
    ch_to[ch_cnt] = v;
    ch_nxt[ch_cnt] = ch_head[u];
    ch_head[u] = ch_cnt++;
}

// BFS to root the tree at node 1
void root_tree() {
    int ql = 0, qr = 0;
    q[qr++] = 1;
    parent_node[1] = 0;
    visited[1] = true;
    
    while (ql < qr) {
        int u = q[ql++];
        for (int e = head[u]; e != -1; e = nxt[e]) {
            int v = to[e];
            if (!visited[v]) {
                visited[v] = true;
                parent_node[v] = u;
                add_child(u, v);
                q[qr++] = v;
            }
        }
    }
}

// Iterative DFS to compute f[] and s[]
void compute_all_fs(int root) {
    int top = 0;
    stk[top] = root;
    stk_e[top] = ch_head[root];
    top++;
    
    while (top > 0) {
        int u = stk[top - 1];
        int e = stk_e[top - 1];
        
        if (e != -1) {
            int c = ch_to[e];
            stk_e[top - 1] = ch_nxt[e];
            stk[top] = c;
            stk_e[top] = ch_head[c];
            top++;
        } else {
            top--;
            
            // Gather children
            int k = 0;
            for (int ee = ch_head[u]; ee != -1; ee = ch_nxt[ee]) {
                ch[k++] = ch_to[ee];
            }
            
            if (k == 0) {
                // Leaf node
                f_val[u] = 2;
                s_val[u] = 1;
            } else {
                // Internal node - use prefix-suffix trick
                long long prod_all = 1;
                for (int i = 0; i < k; i++) {
                    prefix_buf[i] = prod_all;
                    prod_all = prod_all * f_val[ch[i]] % NoD;
                }
                
                long long suf = 1, sum_ch = 0;
                for (int i = k - 1; i >= 0; i--) {
                    sum_ch = (sum_ch + s_val[ch[i]] * (prefix_buf[i] * suf % NoD)) % NoD;
                    suf = suf * f_val[ch[i]] % NoD;
                }
                
                f_val[u] = (1 + prod_all) % NoD;
                s_val[u] = (prod_all + sum_ch) % NoD;
            }
        }
    }
}

int main() {
    memset(head, -1, sizeof(head));
    memset(ch_head, -1, sizeof(ch_head));
    
    n = read(); start_node = read();
    
    for (int i = 0; i < n - 1; i++) {
        int u = read(), v = read();
        add_edge(u, v);
        add_edge(v, u);
    }
    
    root_tree();
    
    // Find path from start_node to root
    int path_len = 0;
    int cur = start_node;
    while (cur != 0) {
        path[path_len++] = cur;
        on_path[cur] = true;
        cur = parent_node[cur];
    }
    int depth = path_len - 1;
    
    // Compute f[] and s[] for all non-path subtrees
    for (int i = 0; i < path_len; i++) {
        int p = path[i];
        for (int e = ch_head[p]; e != -1; e = ch_nxt[e]) {
            int c = ch_to[e];
            if (!on_path[c]) compute_all_fs(c);
        }
    }
    
    // Compute H[] and G[] for path nodes
    for (int i = 0; i < path_len; i++) {
        int p = path[i];
        int k = 0;
        for (int e = ch_head[p]; e != -1; e = ch_nxt[e]) {
            int c = ch_to[e];
            if (!on_path[c]) npc[k++] = c;
        }
        
        if (k == 0) {
            H[i] = 1; G[i] = 0;
        } else {
            bool is_root = (p == 1);
            long long prod_all = 1;
            for (int j = 0; j < k; j++) {
                long long fj = is_root ? (f_val[npc[j]] - 1 + NoD) % NoD : f_val[npc[j]];
                prefix_buf[j] = prod_all;
                prod_all = prod_all * fj % NoD;
            }
            H[i] = prod_all;
            
            long long suf = 1, sum_g = 0;
            for (int j = k - 1; j >= 0; j--) {
                long long fj = is_root ? (f_val[npc[j]] - 1 + NoD) % NoD : f_val[npc[j]];
                sum_g = (sum_g + s_val[npc[j]] * (prefix_buf[j] * suf % NoD)) % NoD;
                suf = suf * fj % NoD;
            }
            G[i] = sum_g;
        }
    }
    
    // Compute final answer using prefix-suffix
    long long N = 1;
    for (int i = 0; i < path_len; i++) {
        prefix_buf[i] = N;
        N = N * H[i] % NoD;
    }
    
    long long suf = 1, total_visited = 0;
    for (int i = path_len - 1; i >= 0; i--) {
        total_visited = (total_visited + G[i] * (prefix_buf[i] * suf % NoD)) % NoD;
        suf = suf * H[i] % NoD;
    }
    
    printf("%lld\n", (N * depth % NoD + 2 * total_visited % NoD) % NoD);
    
    return 0;
}
```

---

## 11. CÃ¡c lá»—i thÆ°á»ng gáº·p

### Lá»—i 1: QuÃªn xá»­ lÃ½ Ä‘áº·c biá»‡t táº¡i gá»‘c

âŒ **Sai:** DÃ¹ng $f(c)$ cho táº¥t cáº£ cÃ¡c nÃºt  
âœ… **ÄÃºng:** Táº¡i gá»‘c dÃ¹ng $(f(c) - 1)$ vÃ¬ báº¯t buá»™c pháº£i thÄƒm

### Lá»—i 2: Stack overflow vá»›i DFS Ä‘á»‡ quy

âŒ **Sai:** DFS Ä‘á»‡ quy vá»›i $n = 10^6$  
âœ… **ÄÃºng:** DÃ¹ng DFS iterative vá»›i stack tá»± quáº£n lÃ½

### Lá»—i 3: TrÃ n sá»‘ khi nhÃ¢n

âŒ **Sai:** NhÃ¢n trÆ°á»›c rá»“i mod sau  
âœ… **ÄÃºng:** Mod sau má»—i phÃ©p nhÃ¢n: `a * b % NoD`

### Lá»—i 4: Chia trong modular arithmetic

âŒ **Sai:** DÃ¹ng phÃ©p chia `/` Ä‘á»ƒ tÃ­nh $\prod_{j \neq i}$  
âœ… **ÄÃºng:** DÃ¹ng ká»¹ thuáº­t prefix-suffix Ä‘á»ƒ trÃ¡nh chia

### Lá»—i 5: TLE do I/O cháº­m

âŒ **Sai:** DÃ¹ng `cin/cout` khÃ´ng tá»‘i Æ°u  
âœ… **ÄÃºng:** DÃ¹ng `scanf/printf` hoáº·c `getchar()` tá»± viáº¿t

---

## ğŸ“š BÃ i táº­p liÃªn quan

1. **Äáº¿m Ä‘Æ°á»ng Ä‘i trÃªn cÃ¢y** - Tree DP cÆ¡ báº£n
2. **Tá»•ng khoáº£ng cÃ¡ch trÃªn cÃ¢y** - Rerooting technique
3. **Äáº¿m cÃ¢y con** - Combinatorics on trees

---

> **TÃ¡c giáº£:** Claude AI  
> **NgÃ y viáº¿t:** 2024  
> **Äá»™ khÃ³ Ä‘á» xuáº¥t:** VNOI Rating 1800-2000
