# Tutorial: Đếm Bước Đi Trên Cây

---

## 1. Tóm tắt đề bài

### Đầu vào
- Cây $T$ gồm $n$ đỉnh, gốc tại đỉnh $1$
- Đỉnh xuất phát $s$
- $n-1$ cạnh $(u, v)$ với $1 \le u, v \le n$, $u \neq v$

### Quy tắc di chuyển
- Từ đỉnh $u$, đi đến bất kỳ đỉnh kề nào
- **Quan trọng:** Nếu đi từ $u$ lên cha $f$ → cạnh $(u, f)$ bị **xóa ngay lập tức**
- Dừng khi đỉnh hiện tại không còn cạnh kề

### Yêu cầu
- Hai phương án **bản chất khác nhau** ⟺ tồn tại đỉnh được thăm trong phương án này nhưng không được thăm trong phương án kia
- Tính **tổng số bước** của tất cả phương án bản chất khác nhau
- Kết quả mod $10^9 + 7$

### Ràng buộc
- $1 \le s \le n \le 10^6$

---

## 2. Phân tích ví dụ

### Cấu trúc cây

```
        1           ← Gốc (kết thúc tại đây)
        |
        2
       / \
      3   4
     / \
    5   7
    |
   6

Đường chính: 5 → 3 → 2 → 1
Nhánh phụ: {4}, {6}, {7}
```

### 8 phương án bản chất khác nhau

| # | Phương án | Đỉnh thăm | Số bước |
|---|-----------|-----------|---------|
| 1 | 5→3→2→1 | {5,3,2,1} | 3 |
| 2 | 5→3→7→3→2→1 | {5,3,2,1,7} | 5 |
| 3 | 5→3→7→3→2→4→2→1 | {5,3,2,1,7,4} | 7 |
| 4 | 5→3→2→4→2→1 | {5,3,2,1,4} | 5 |
| 5 | 5→6→5→3→2→1 | {5,3,2,1,6} | 5 |
| 6 | 5→6→5→3→7→3→2→1 | {5,3,2,1,6,7} | 7 |
| 7 | 5→6→5→3→2→4→2→1 | {5,3,2,1,6,4} | 7 |
| 8 | 5→6→5→3→7→3→2→4→2→1 | {5,3,2,1,6,7,4} | 9 |

**Tổng:** $3+5+7+5+5+7+7+9 = 48$

### Từ ví dụ, ta có:

1. **Đường chính** $\{5,3,2,1\}$ luôn được thăm trong mọi phương án
2. Mỗi nhánh phụ $\{4\}, \{6\}, \{7\}$ có thể **chọn hoặc không chọn** thăm
3. Số phương án = $2^3 = 8$ (mỗi nhánh có 2 lựa chọn)
4. Thăm 1 đỉnh nhánh = thêm 2 bước (đi vào + đi ra)

---

## 3. Mô hình hóa bài toán

### Bước 1: Xác định cấu trúc

Gọi **đường chính** là đường đi từ $s$ đến gốc $1$:
$$P = \{p_0 = s, p_1, p_2, \ldots, p_m = 1\}$$

Các đỉnh **không thuộc** đường chính tạo thành các **cây con nhánh**.

### Bước 2: Đặc trưng phương án

Một phương án được xác định **hoàn toàn** bởi tập đỉnh được thăm.

**Nhận xét:** Với mỗi cây con nhánh, ta có thể:
- Không thăm gì cả
- Thăm một tập con các đỉnh (theo quy tắc: muốn thăm con thì phải thăm cha)

### Bước 3: Công thức tổng bước

$$\text{Tổng bước} = \sum_{\text{phương án } A} \text{steps}(A)$$

Trong đó:
$$\text{steps}(A) = |P| - 1 + 2 \times |\text{đỉnh nhánh được thăm}|$$

- $|P| - 1 = m$: số bước đi trên đường chính (cố định)
- Mỗi đỉnh nhánh đóng góp 2 bước

---

## 4. Nhận xét

### Nhận xét 1: Luôn kết thúc tại gốc

> **Chứng minh:** Để dừng lại, ta phải đứng ở đỉnh không còn cạnh kề. Vì mỗi lần đi lên cha thì xóa cạnh, và ta phải xóa hết cạnh mới dừng được, nên chỉ có thể dừng tại gốc sau khi đã thăm tất cả cây con của gốc.

**Hệ quả:** Tại gốc, ta **bắt buộc** phải thăm tất cả cây con.

### Nhận xét 2: Tính độc lập của các nhánh

> Việc chọn thăm hay không thăm một cây con nhánh **không ảnh hưởng** đến các cây con khác.

**Ý nghĩa:** Ta có thể tính riêng cho từng cây con rồi **nhân** kết quả lại.

### Nhận xét 3: Cấu trúc đệ quy của cây con

> Trong một cây con gốc $v$:
> - Nếu không thăm $v$: không thăm gì cả
> - Nếu thăm $v$: phải thăm $v$, và với mỗi con của $v$, ta lại có bài toán con tương tự

### Nhận xét 4: Đóng góp bước của mỗi đỉnh

> Mỗi đỉnh nhánh được thăm đóng góp **đúng 2 bước** (vào và ra).

**Chứng minh:** Khi vào một cây con từ đỉnh $p$ trên đường chính, ta phải quay lại $p$ để tiếp tục đi lên. Mỗi đỉnh trong cây con được đi qua đúng 2 lần.

---

## 5. Phân rã bài toán con

### Bài toán con 1: Tìm đường chính

**Input:** Cây $T$, đỉnh $s$  
**Output:** Danh sách đỉnh $P = \{s, p_1, \ldots, 1\}$

**Cách giải:** BFS/DFS từ gốc để tìm cha của mỗi đỉnh, sau đó đi ngược từ $s$ lên gốc.

### Bài toán con 2: Đếm số cách trong cây con

**Input:** Cây con gốc $v$ (không thuộc đường chính)  
**Output:** 
- $f(v)$: số cách xử lý cây con (bao gồm cả "không thăm")
- $s(v)$: tổng số đỉnh được thăm qua tất cả các cách (khi thăm $v$)

### Bài toán con 3: Tổng hợp kết quả

**Input:** Các giá trị $f, s$ của các cây con nhánh  
**Output:** Tổng số bước

---

## 6. Xây dựng công thức

### 6.1. Công thức đệ quy cho $f(v)$ và $s(v)$

**Trường hợp cơ sở:** $v$ là lá
$$f(v) = 2, \quad s(v) = 1$$
- 2 cách: thăm hoặc không thăm
- Nếu thăm: thăm đúng 1 đỉnh

**Trường hợp đệ quy:** $v$ có các con $c_1, c_2, \ldots, c_k$

$$f(v) = 1 + \prod_{i=1}^{k} f(c_i)$$

- Số 1: không thăm $v$
- Tích: thăm $v$, rồi với mỗi con có $f(c_i)$ cách

$$s(v) = \prod_{i=1}^{k} f(c_i) + \sum_{i=1}^{k} \left( s(c_i) \times \prod_{j \neq i} f(c_j) \right)$$

- Phần tích đầu: đếm chính đỉnh $v$
- Phần tổng: đóng góp từ các cây con

### 6.2. Xử lý đặc biệt tại gốc

Tại **gốc (đỉnh 1)**, ta **bắt buộc** phải thăm tất cả cây con (theo Nhận xét 1).

→ Dùng $(f(c) - 1)$ thay vì $f(c)$ để loại bỏ lựa chọn "không thăm".


### 6.3. Công thức tổng hợp

Gọi các đỉnh trên đường chính là $p_0, p_1, \ldots, p_m$.

Với mỗi $p_i$, định nghĩa:
- $H_i$ = tích các factor của các cây con nhánh tại $p_i$
- $G_i$ = tổng $s$ của các cây con nhánh tại $p_i$

**Factor:**
$$\text{factor}(c) = \begin{cases} f(c) - 1 & \text{if } p_i = 1 \text{ (root)} \\ f(c) & \text{otherwise} \end{cases}$$

---

## 7. Thuật toán chi tiết

### Bước 1: Đọc input và xây dựng cây

```
Đọc n, s
Đọc n-1 cạnh, lưu vào danh sách kề adj[]
```

### Bước 2: Root cây tại đỉnh 1

```
BFS từ đỉnh 1
Với mỗi đỉnh v, lưu parent[v] và children[v]
```

### Bước 3: Tìm đường chính

```
path = []
v = s
while v != 0:
    path.append(v)
    mark on_path[v] = true
    v = parent[v]
depth = len(path) - 1
```

### Bước 4: Tính f[] và s[] cho các cây con nhánh

```
Với mỗi đỉnh p trên đường chính:
    Với mỗi con c của p:
        Nếu c không thuộc đường chính:
            DFS(c) để tính f[c], s[c]
```

**DFS tính f và s (dạng iterative để tránh stack overflow):**

```
function compute_fs(root):
    stack = [(root, 0)]  # (node, child_index)
    
    while stack not empty:
        (u, idx) = stack.top()
        
        if idx < len(children[u]):
            c = children[u][idx]
            stack.top().idx++
            stack.push((c, 0))
        else:
            stack.pop()
            
            if children[u] is empty:
                f[u] = 2
                s[u] = 1
            else:
                prod = 1
                for c in children[u]:
                    prod *= f[c]
                f[u] = 1 + prod
                
                sum_s = prod  # đếm chính u
                for c in children[u]:
                    sum_s += s[c] * (prod / f[c])
                s[u] = sum_s
```

### Bước 5: Tính H[] và G[] cho đường chính

```
for i = 0 to m:
    p = path[i]
    H[i] = 1
    G[i] = 0
    
    for c in non_path_children[p]:
        factor = (f[c] - 1) if (p == 1) else f[c]
        
        # Cập nhật G trước khi cập nhật H
        G[i] = G[i] * factor + s[c] * H[i]
        H[i] = H[i] * factor
```

### Bước 6: Tính kết quả cuối cùng

```
# Dùng prefix-suffix để tính hiệu quả
prefix[0] = 1
for i = 0 to m-1:
    prefix[i+1] = prefix[i] * H[i]

N = prefix[m+1]  # tích tất cả H

suffix[m+1] = 1
for i = m downto 0:
    suffix[i] = suffix[i+1] * H[i]

total_visited = 0
for i = 0 to m:
    total_visited += G[i] * prefix[i] * suffix[i+1]

answer = N * depth + 2 * total_visited
```

---

## 8. Phân tích độ phức tạp

### Thời gian

| Bước | Độ phức tạp | Giải thích |
|------|-------------|------------|
| Root cây | $O(n)$ | BFS một lần |
| Tìm đường chính | $O(n)$ | Tối đa $n$ đỉnh |
| Tính f[], s[] | $O(n)$ | Mỗi đỉnh xử lý một lần |
| Tính H[], G[] | $O(n)$ | Tổng số cây con nhánh ≤ $n$ |
| Tổng hợp kết quả | $O(n)$ | Prefix-suffix |

**Tổng:** $O(n)$

### Không gian

| Thành phần | Độ phức tạp |
|------------|-------------|
| Danh sách kề | $O(n)$ |
| Mảng f[], s[] | $O(n)$ |
| Stack DFS | $O(n)$ |
| Đường chính | $O(n)$ |

**Tổng:** $O(n)$
